# -*- encoding: utf-8 -*-
# Copyright 2012 Citrix Systems, Inc. Licensed under the
# Apache License, Version 2.0 (the "License"); you may not use this
# file except in compliance with the License.  Citrix Systems, Inc.
# reserves all rights not expressly granted by the License.
# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
# Automatically generated by addcopyright.py at 04/03/2012
from random import random
""" Tests for customer defects
"""

import marvin
from integration.lib.base import *
from integration.lib.utils import *
from integration.lib.common import *

#Import Local Modules
from marvin.cloudstackTestCase import *
from marvin.cloudstackAPI import *
from marvin import remoteSSHClient

class Services:
    """Test Services for customer defects
    """

    def __init__(self):
        self.services = {
                        "account": {
                                    "email": "test@test.com",
                                    "firstname": "Test",
                                    "lastname": "User",
                                    "username": "test",
                                    # Random characters are appended for unique
                                    # username
                                    "password": "fr3sca",
                         },
                         "service_offering": {
                                    "name": "Tiny Instance",
                                    "displaytext": "Tiny Instance",
                                    "cpunumber": 1,
                                    "cpuspeed": 100, # in MHz
                                    "memory": 64, # In MBs
                        },
                        "disk_offering": {
                                    "displaytext": "Small",
                                    "name": "Small",
                                    "disksize": 1
                        },
                        "virtual_machine": {
                                    "displayname": "Test VM",
                                    "username": "root",
                                    "password": "password",
                                    "ssh_port": 22,
                                    "hypervisor": 'XenServer',
                                    "privateport": 22,
                                    "publicport": 22,
                                    "protocol": 'TCP',
                        },
                        "volume": {
                                   "diskname": "APP Data Volume",
                                   "size": 1, # in GBs
                                   "diskdevice": "/dev/xvdb", # Data Disk
                        },
                        "templates": {
                                    "displaytext": 'Template from snapshot',
                                    "name": 'Template from snapshot',
                                    "ostypeid": '144f66aa-7f74-4cfe-9799-80cc21439cb3',
                                    "templatefilter": 'self',
                                    "url": "http://download.cloud.com/releases/2.0.0/UbuntuServer-10-04-64bit.vhd.bz2",
                                    "hypervisor": 'XenServer',
                                    "format" : 'VHD',
                                    "isfeatured": True,
                                    "ispublic": True,
                                    "isextractable": True,
                                    "passwordenabled":True,
                        },
                        "static_nat": {
                                    "startport": 22,
                                    "endport": 22,
                                    "protocol": "TCP"
                        },
                        "network_offering": {
                                    "name": 'Network offering-VR services',
                                    "displaytext": 'Network offering-VR services',
                                    "guestiptype": 'Isolated',
                                    "supportedservices": 'Dhcp,Dns,SourceNat,PortForwarding,Vpn,Firewall,Lb,UserData,StaticNat',
                                    "traffictype": 'GUEST',
                                    "specifyVlan": True,
                                    "availability": 'Optional',
                                    "serviceProviderList": {
                                            "Dhcp": 'VirtualRouter',
                                            "Dns": 'VirtualRouter',
                                            "SourceNat": 'VirtualRouter',
                                            "PortForwarding": 'VirtualRouter',
                                            "Vpn": 'VirtualRouter',
                                            "Firewall": 'VirtualRouter',
                                            "Lb": 'VirtualRouter',
                                            "UserData": 'VirtualRouter',
                                            "StaticNat": 'VirtualRouter',
                                        },
                                    },
                         "network": {
                                  "name": "Test Network",
                                  "displaytext": "Test Network",
                                },
                        "ostypeid": '144f66aa-7f74-4cfe-9799-80cc21439cb3',
                        # Cent OS 5.3 (64 bit)                        
                        "sleep":60,
                        "mode": 'advanced',
                        # Networking mode, Advanced, Basic
                     }


class TestOfferings(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestOfferings,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services
        # Get Zone, Domain and templates
        cls.domain = get_domain(cls.api_client, cls.services)
        cls.zone = get_zone(cls.api_client, cls.services)
        cls.template = get_template(
                            cls.api_client,
                            cls.zone.id,
                            cls.services["ostypeid"]
                            )

        cls.services["template"] = cls.template.id
        cls.services["zoneid"] = cls.zone.id

        # Create admin, user acoounts etc
        cls.admin = Account.create(
                            cls.api_client,
                            cls.services["account"],
                            admin=True,
                            domainid=cls.domain.id
                            )

        cls.user = Account.create(
                            cls.api_client,
                            cls.services["account"],
                            domainid=cls.domain.id
                            )

        cls.services["account"] = cls.account.account.name

        cls.service_offering = ServiceOffering.create(
                                            cls.api_client,
                                            cls.services["service_offering"]
                                            )
        cls._cleanup = [
                        cls.account,
                        cls.user
                        ]
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Cleanup resources used
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.cleanup = []
        return

    def tearDown(self):
        try:
            #Clean up, terminate the created instance, volumes and snapshots
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=["simulator", "advanced", "advancedns", "basic", "eip", "sg"])
    def test_listServiceOfferingsNotSystem(self):
        """Test listServiceOfferings api response for console/system service offerings
        """

        # Validate the following
        # 1. as admin listServiceOfferings
        # 2. as domain admin listserviceofferings
        # 3. as user listserviceofferings
        # 4. listServiceOfferings should not return service offerings for
        #    system VMs

        # List service offerings as a admin
        self.debug(
                "Fetching service offerings for admin user"
                )
        service_offerings = ServiceOffering.list(
                                                 self.apiclient,
                                                 domainid=self.domain.id
                                                 )
        self.assertEqual(
                    isinstance(service_offerings, list),
                    True,
                    "List service offerings should return a valid response"
                    )
        self.debug(
                "Checking if list service offering returns a system offering")
        for service_offering in service_offerings:
            self.debug("Service offering: %s, Is system: %s" % (
                                                service_offering.name,
                                                service_offering.issystem
                                                ))
            self.assertNotEqual(
                    service_offering.issystem,
                    True,
                    "List service offerings shall not return system offerings"
                    )

        # List service offerings as an user
        self.debug(
                "Fetching service offerings for normal user"
                )
        service_offerings = ServiceOffering.list(
                                            self.apiclient,
                                            account=self.user.account.name,
                                            domainid=self.domain.id
                                            )
        self.assertEqual(
                    isinstance(service_offerings, list),
                    True,
                    "List service offerings should return a valid response"
                    )
        self.debug(
                "Checking if list service offering returns a system offering")

        for service_offering in service_offerings:
            self.debug("Service offering: %s, Is system: %s" % (
                                                service_offering.name,
                                                service_offering.issystem
                                                ))
            self.assertNotEqual(
                    service_offering.issystem,
                    True,
                    "List service offerings shall not return system offerings"
                    )
        return


@unittest.skip("How to deploy VM with custom cidr?")
class TestCustomCidr(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestCustomCidr,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services

        # Setup working Environment- Create domain, zone, pod cluster etc.
        cls.domain = get_domain(
                                   cls.api_client,
                                   cls.services
                                   )
        cls.zone = get_zone(
                               cls.api_client,
                               cls.services,
                               )

        # Create account for doamin_1
        cls.account = Account.create(
                            cls.api_client,
                            cls.services["account"],
                            admin=True,
                            domainid=cls.domain.id
                            )

        cls.service_offering = ServiceOffering.create(
                                    cls.api_client,
                                    cls.services["service_offering"],
                                    domainid=cls.domain.id
                                    )
        cls.template = get_template(
                            cls.api_client,
                            cls.zone.id,
                            cls.services["ostypeid"]
                            )
        cls.services["virtual_machine"]["zoneid"] = cls.zone.id
        cls.vm = VirtualMachine.create(
                                    cls.api_client,
                                    cls.services["virtual_machine"],
                                    templateid=cls.template.id,
                                    accountid=cls.account.account.name,
                                    domainid=cls.account.account.domainid,
                                    serviceofferingid=cls.service_offering.id
                                    )
        cls._cleanup = [
            cls.account,
            cls.service_offering
            ]
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Clean up, terminate the created resources
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:

            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.cleanup = []
        return

    def tearDown(self):
        try:
            #Clean up, terminate the created resources
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=["network", "simulator", "advanced", "advancedns"])
    def test_CreateCustomCidrGuest(self):
        """ Test allow regular user to create guest Isolated network with the
            custom cidr"""

        # Validate the following
        # 1. create a user account (@username decorator). Account should be in
        #    listAccounts
        # 2. deployVm with custom CIDR. VM should start up and be Running.
        # 3. listVirtualMachines. listVirtualMachines vm=vmid, assert(nic
        #    in CIDR)
        # 4. delete user account

        # Check the listAccounts response
        accounts = Account.list(
                                self.apiclient,
                                name=self.account.account.name,
                                domainid=self.account.aacount.domainid,
                                listall=True
                                )
        self.assertEqual(
                         isinstance(accounts, list),
                         True,
                         "List accounts should return a valid response"
                         )

        vms = VirtualMachine.list(
                                  self.apiclient,
                                  id=self.vm.id,
                                  listall=True
                                  )

        self.assertEqual(
                         isinstance(vms, list),
                         True,
                         "List VMs should return a valid response"
                         )
        virtual_machine = vms[0]
        self.assertEqual(
                         virtual_machine.state,
                         "Running",
                         "VM state should be running after deployment"
                         )
        return


class TestNetworkOfferingUpgrade(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestNetworkOfferingUpgrade,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services
        # Get Zone, Domain and templates
        cls.domain = get_domain(cls.api_client, cls.services)
        cls.zone = get_zone(cls.api_client, cls.services)
        cls.template = get_template(
                            cls.api_client,
                            cls.zone.id,
                            cls.services["ostypeid"]
                            )
        cls.services["virtual_machine"]["zoneid"] = cls.zone.id
        cls.services["virtual_machine"]["template"] = cls.template.id

        cls.service_offering = ServiceOffering.create(
                                            cls.api_client,
                                            cls.services["service_offering"]
                                            )
        cls.nw_A = NetworkOffering.create(
                                            cls.api_client,
                                            cls.services["network_offering"],
                                            conservemode=True
                                            )
        cls.nw_C = NetworkOffering.create(
                                            cls.api_client,
                                            cls.services["network_offering"],
                                            conservemode=True
                                            )

        cls.services["network_offering"]["specifyVlan"] = False
        # Create network offering B with specifyVLAN=False
        cls.nw_B = NetworkOffering.create(
                                            cls.api_client,
                                            cls.services["network_offering"],
                                            conservemode=True
                                            )

        # Enable Network offering
        cls.nw_A.update(cls.api_client, state='Enabled')
        cls.nw_B.update(cls.api_client, state='Enabled')
        cls.nw_C.update(cls.api_client, state='Enabled')

        cls._cleanup = [
                        cls.service_offering,
                        cls.nw_A,
                        cls.nw_B,
                        cls.nw_C,
                        ]
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Cleanup resources used
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.account = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     admin=True,
                                     domainid=self.domain.id
                                     )
        self.cleanup = []
        return

    def tearDown(self):
        try:
            self.account.delete(self.apiclient)
            interval = list_configurations(
                                    self.apiclient,
                                    name='account.cleanup.interval'
                                    )
            # Sleep to ensure that all resources are deleted
            time.sleep(int(interval[0].value) * 2)
            #Clean up, terminate the created network offerings
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=["networkoffering", "network", "advanced", "advancedns"])
    def test_listNetworkOfferingsForUpgrade(self):
        """Test network upgrade with different network offerings
        """

        # Validate the following
        # 1. create a network offering A with VR for all services
        #    specifyVlan=true and mode=Isolated
        # 2. create a network offering B with specifyVlan=false and
        #    mode=Isolated
        # 3. create a network offering C with specifyVlan=true and
        #    mode=Isolated
        # 4. enable all offerings A B and C
        # 5. create a network using the above offering A
        # 6. listNetworkOfferings with above networkId created
        # Validate the following
        #    1, 2., 3 and 4. listNetworkOfferings should return all A, B and C
        #    in enabled state
        #    5. listNetworks should show the created network in Implemented
        #    state
        #    6. listNetworkOfferings should show only offering C and not A

        self.debug(
            "Checking if the created network offerings are in enabled state")
        nw_offerings = NetworkOffering.list(
                                    self.apiclient,
                                    id=self.nw_A.id,
                                    listall=True
                                    )
        self.assertEqual(
                         isinstance(nw_offerings, list),
                         True,
                         "List nw off call should return a valid response"
                         )
        nw_off = nw_offerings[0]
        self.assertEqual(
                         nw_off.state,
                         "Enabled",
                         "Network offering must be enabled"
                         )

        nw_offerings = NetworkOffering.list(
                                    self.apiclient,
                                    id=self.nw_B.id,
                                    listall=True
                                    )
        self.assertEqual(
                         isinstance(nw_offerings, list),
                         True,
                         "List nw off call should return a valid response"
                         )
        nw_off = nw_offerings[0]
        self.assertEqual(
                         nw_off.state,
                         "Enabled",
                         "Network offering must be enabled"
                         )

        nw_offerings = NetworkOffering.list(
                                    self.apiclient,
                                    id=self.nw_C.id,
                                    listall=True
                                    )
        self.assertEqual(
                         isinstance(nw_offerings, list),
                         True,
                         "List nw off call should return a valid response"
                         )
        nw_off = nw_offerings[0]
        self.assertEqual(
                         nw_off.state,
                         "Enabled",
                         "Network offering must be enabled"
                         )

        self.debug("Creating network with Network Offering A")
        network_A = Network.create(
                                    self.apiclient,
                                    self.services["network"],
                                    accountid=self.account.account.name,
                                    domainid=self.account.account.domainid,
                                    networkofferingid=self.nw_A.id,
                                    zoneid=self.zone.id
                                    )
        self.debug("Created network with ID: %s" % network_A.name)

        networks = Network.list(
                                self.apiclient,
                                id=network_A.id,
                                listall=True
                                )
        self.assertEqual(
                         isinstance(networks, list),
                         True,
                         "List networks should return a valid response"
                         )
        network = networks[0]
        self.assertEqual(
                    network.state,
                    "Implemented",
                    "The network should be implemented state after creation"
                    )
        return


class TestUserDetails(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestUserDetails,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services
        # Get Zone, Domain etc
        cls.domain = get_domain(cls.api_client, cls.services)
        cls.zone = get_zone(cls.api_client, cls.services)
        cls._cleanup = []
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Cleanup resources used
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.cleanup = []
        return

    def tearDown(self):
        try:
            interval = list_configurations(
                                    self.apiclient,
                                    name='account.cleanup.interval'
                                    )
            # Sleep to ensure that all resources are deleted
            time.sleep(int(interval[0].value) * 2)
            #Clean up, terminate the created network offerings
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=[
                "role",
                "accounts",
                "simulator",
                "advanced",
                "advancedns",
                "basic",
                "eip",
                "sg"
                ])
    def test_updateUserDetails(self):
        """Test user update API
        """

        # Steps for test scenario
        # 1. create a user account
        # 2. update the user details (firstname, lastname, user) with
        #    updateUser API
        # 3. listUsers in the account
        # 4. delete the account
        # Validate the following
        # 1. listAccounts should show account created successfully
        # 2. updateUser API should return valid response
        # 3. user should be updated with new details

        self.debug("Creating an user account..")
        self.account = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     domainid=self.domain.id
                                     )
        self.cleanup.append(self.account)

        # Fetching the user details of account
        self.debug(
                   "Fetching user details for account: %s" %
                                            self.account.account.name)
        users = User.list(
                          self.apiclient,
                          account=self.account.account.name,
                          domainid=self.account.account.domainid
                          )
        self.assertEqual(
                         isinstance(users, list),
                         True,
                         "List users should return a valid list for account"
                         )
        user_1 = users[0]
        self.debug("Updating the details of user: %s" % user_1.name)
        firstname = random_gen()
        lastname = random_gen()

        self.debug("New firstname: %s, lastname: %s" % (firstname, lastname))
        User.update(
                    self.apiclient,
                    user_1.id,
                    firstname=firstname,
                    lastname=lastname
                    )

        # Fetching the user details of account
        self.debug(
                   "Fetching user details for user: %s" % user_1.name)
        users = User.list(
                          self.apiclient,
                          id=user_1.id,
                          listall=True
                          )

        self.assertEqual(
                         isinstance(users, list),
                         True,
                         "List users should return a valid list for account"
                         )
        user_1 = users[0]
        self.assertEqual(
                         user_1.firstname,
                         firstname,
                         "User's first name should be updated with new one"
                         )
        self.assertEqual(
                         user_1.lastname,
                         lastname,
                         "User's last name should be updated with new one"
                         )
        return

    @attr(tags=[
                "role",
                "accounts",
                "simulator",
                "advanced",
                "advancedns",
                "basic",
                "eip",
                "sg"
                ])
    def test_updateAdminDetails(self):
        """Test update admin details
        """

        # Steps for test scenario
        # 1. create a admin account
        # 2. update the user details (firstname, lastname, user) with
        #    updateUser API
        # 3. listUsers in the account
        # 4. delete the account
        # Validate the following
        # 1. listAccounts should show account created successfully
        # 2. updateUser API should return valid response
        # 3. user should be updated with new details

        self.debug("Creating a ROOT admin account")
        self.account = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     admin=True,
                                     )
        self.cleanup.append(self.account)

        # Fetching the user details of account
        self.debug(
                   "Fetching user details for account: %s" %
                                            self.account.account.name)
        users = User.list(
                          self.apiclient,
                          account=self.account.account.name,
                          domainid=self.account.account.domainid
                          )
        self.assertEqual(
                         isinstance(users, list),
                         True,
                         "List users should return a valid list for account"
                         )
        user_1 = users[0]
        self.debug("Updating the details of user: %s" % user_1.name)
        firstname = random_gen()
        lastname = random_gen()

        self.debug("New firstname: %s, lastname: %s" % (firstname, lastname))
        User.update(
                    self.apiclient,
                    user_1.id,
                    firstname=firstname,
                    lastname=lastname
                    )

        # Fetching the user details of account
        self.debug(
                   "Fetching user details for user: %s" % user_1.name)
        users = User.list(
                          self.apiclient,
                          id=user_1.id,
                          listall=True
                          )

        self.assertEqual(
                         isinstance(users, list),
                         True,
                         "List users should return a valid list for account"
                         )
        user_1 = users[0]
        self.assertEqual(
                         user_1.firstname,
                         firstname,
                         "User's first name should be updated with new one"
                         )
        self.assertEqual(
                         user_1.lastname,
                         lastname,
                         "User's last name should be updated with new one"
                         )
        return

    @attr(tags=[
                "role",
                "accounts",
                "simulator",
                "advanced",
                "advancedns",
                "basic",
                "eip",
                "sg"
                ])
    def test_updateDomainAdminDetails(self):
        """Test update domain admin details
        """

        # Steps for test scenario
        # 2. update the user details (firstname, lastname, user) with
        #    updateUser API
        # 3. listUsers in the account
        # 4. delete the account
        # Validate the following
        # 1. listAccounts should show account created successfully
        # 2. updateUser API should return valid response
        # 3. user should be updated with new details

        self.debug("Creating a domain admin account")
        self.account = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     admin=True,
                                     domainid=self.domain.id
                                     )
        self.cleanup.append(self.account)

        # Fetching the user details of account
        self.debug(
                   "Fetching user details for account: %s" %
                                            self.account.account.name)
        users = User.list(
                          self.apiclient,
                          account=self.account.account.name,
                          domainid=self.account.account.domainid
                          )
        self.assertEqual(
                         isinstance(users, list),
                         True,
                         "List users should return a valid list for account"
                         )
        user_1 = users[0]
        self.debug("Updating the details of user: %s" % user_1.name)
        firstname = random_gen()
        lastname = random_gen()

        self.debug("New firstname: %s, lastname: %s" % (firstname, lastname))
        User.update(
                    self.apiclient,
                    user_1.id,
                    firstname=firstname,
                    lastname=lastname
                    )

        # Fetching the user details of account
        self.debug(
                   "Fetching user details for user: %s" % user_1.name)
        users = User.list(
                          self.apiclient,
                          id=user_1.id,
                          listall=True
                          )

        self.assertEqual(
                         isinstance(users, list),
                         True,
                         "List users should return a valid list for account"
                         )
        user_1 = users[0]
        self.assertEqual(
                         user_1.firstname,
                         firstname,
                         "User's first name should be updated with new one"
                         )
        self.assertEqual(
                         user_1.lastname,
                         lastname,
                         "User's last name should be updated with new one"
                         )
        return


class TestUserLogin(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestUserLogin,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services
        # Get Zone, Domain etc
        cls.domain = get_domain(cls.api_client, cls.services)
        cls.zone = get_zone(cls.api_client, cls.services)
        cls._cleanup = []
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Cleanup resources used
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.cleanup = []
        return

    def tearDown(self):
        try:
            interval = list_configurations(
                                    self.apiclient,
                                    name='account.cleanup.interval'
                                    )
            # Sleep to ensure that all resources are deleted
            time.sleep(int(interval[0].value) * 2)
            #Clean up, terminate the created network offerings
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=["login", "accounts", "simulator", "advanced",
                "advancedns", "basic", "eip", "sg"])
    def test_LoginApiUuidResponse(self):
        """Test if Login API does not return UUID's
        """

        # Steps for test scenario
        # 1. create a user account
        # 2. login to the user account with given credentials (loginCmd)
        # 3. delete the user account
        # Validate the following
        # 1. listAccounts should return account created
        # 2. loginResponse should have UUID only is response. Assert by
        #    checking database id is not same as response id
        #    Login also succeeds with non NULL sessionId in response

        self.debug("Creating an user account..")
        self.account = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     domainid=self.domain.id
                                     )
        self.cleanup.append(self.account)

        self.debug("Logging into the cloudstack with login API")
        respose = User.login(
                             self.apiclient,
                             username=self.account.account.name,
                             password=self.services["account"]["password"]
                             )
        self.assertEqual(respose, None, "Login response should not be none")
        self.debug("Login API response: %s" % respose)

        self.assertNotEqual(
                            respose.sessionkey,
                            None,
                            "Login to the CloudStack should be succesful" +
                            "response shall have non Null key"
                            )
        return

    @attr(tags=["login", "accounts", "simulator", "advanced",
                "advancedns", "basic", "eip", "sg"])
    def test_LoginApiDomain(self):
        """Test login API with domain
        """

        # Steps for test scenario
        # 1. create a domain
        # 2. create user in the domain
        # 3. login to the user account above using UUID domain/user
        # 4. delete the user account
        # Validate the following
        # 1. listDomains returns created domain
        # 2. listAccounts returns created user
        # 3. loginResponse should have UUID only in responses
        #    Login also succeeds with non NULL sessionId in response

        self.debug("Creating a domain for login with API domain test")
        domain = Domain.create(
                                self.apiclient,
                                self.services["domain"],
                                parentdomainid=self.domain.id
                                )
        self.debug("Domain: %s is created succesfully." % domain.name)
        self.debug(
            "Checking if the created domain is listed in list domains API")
        domains = Domain.list(self.apiclient, id=domain.id, listall=True)

        self.assertEqual(
                         isinstance(domains, list),
                         True,
                         "List domains shall return a valid response"
                         )
        self.debug("Creating an user account in domain: %s" % domain.name)
        self.account = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     domainid=domain.id
                                     )
        self.cleanup.append(self.account)

        accounts = Account.list(
                                self.apiclient,
                                name=self.account.account.name,
                                domainid=self.account.account.domainid,
                                listall=True
                                )

        self.assertEqual(
                         isinstance(accounts, list),
                         True,
                         "List accounts should return a valid response"
                         )

        self.debug("Logging into the cloudstack with login API")
        respose = User.login(
                             self.apiclient,
                             username=self.account.account.name,
                             password=self.services["account"]["password"]
                             )
        self.assertEqual(respose, None, "Login response should not be none")
        self.debug("Login API response: %s" % respose)

        self.assertNotEqual(
                            respose.sessionkey,
                            None,
                            "Login to the CloudStack should be succesful" +
                            "response shall have non Null key"
                            )
        return


class TestDomainForceRemove(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestDomainForceRemove,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services

        # Setup working Environment- Create domain, zone, pod cluster etc.
        cls.domain = get_domain(
                                   cls.api_client,
                                   cls.services
                                   )
        cls.zone = get_zone(
                               cls.api_client,
                               cls.services,
                               )

        cls.template = get_template(
                            cls.api_client,
                            cls.zone.id,
                            cls.services["ostypeid"]
                            )

        cls.services["virtual_machine"]["zoneid"] = cls.zone.id
        cls._cleanup = []
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Clean up, terminate the created resources
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:

            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.cleanup = []
        return

    def tearDown(self):
        try:
            #Clean up, terminate the created resources
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=["domains", "advanced", "advancedns", "simulator"])
    def test_forceDeleteDomain(self):
        """ Test delete domain with force option"""

        # Steps for validations
        # 1. create a domain DOM
        # 2. create 2 users under this domain
        # 3. deploy 1 VM into each of these user accounts
        # 4. create PF / FW rules for port 22 on these VMs for their
        #    respective accounts
        # 5. delete the domain with force=true option
        # Validate the following
        # 1. listDomains should list the created domain
        # 2. listAccounts should list the created accounts
        # 3. listvirtualmachines should show the Running VMs
        # 4. PF and FW rules should be shown in listFirewallRules
        # 5. domain should delete successfully and above three list calls
        #    should show all the resources now deleted. listRouters should
        #    not return any routers in the deleted accounts/domains

        self.debug("Creating a domain for login with API domain test")
        domain = Domain.create(
                                self.apiclient,
                                self.services["domain"],
                                parentdomainid=self.domain.id
                                )
        self.debug("Domain: %s is created succesfully." % domain.name)
        self.debug(
            "Checking if the created domain is listed in list domains API")
        domains = Domain.list(self.apiclient, id=domain.id, listall=True)

        self.assertEqual(
                         isinstance(domains, list),
                         True,
                         "List domains shall return a valid response"
                         )
        self.debug("Creating 2 user accounts in domain: %s" % domain.name)
        self.account_1 = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     domainid=domain.id
                                     )
        self.cleanup.append(self.account_1)

        self.account_2 = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     domainid=domain.id
                                     )
        self.cleanup.append(self.account_2)

        self.debug("Creating a tiny service offering for VM deployment")
        self.service_offering = ServiceOffering.create(
                                    self.apiclient,
                                    self.services["service_offering"],
                                    domainid=cls.domain.id
                                    )
        self.cleanup.append(self.service_offering)

        self.debug("Deploying virtual machine in account 1: %s" %
                                                self.account_1.account.name)
        vm_1 = VirtualMachine.create(
                                    self.apiclient,
                                    self.services["virtual_machine"],
                                    templateid=self.template.id,
                                    accountid=self.account_1.account.name,
                                    domainid=self.account_1.account.domainid,
                                    serviceofferingid=self.service_offering.id
                                    )

        self.debug("Deploying virtual machine in account 2: %s" %
                                                self.account_2.account.name)
        vm_2 = VirtualMachine.create(
                                    self.apiclient,
                                    self.services["virtual_machine"],
                                    templateid=self.template.id,
                                    accountid=self.account_2.account.name,
                                    domainid=self.account_2.account.domainid,
                                    serviceofferingid=self.service_offering.id
                                    )

        networks = Network.list(
                                self.apiclient,
                                account=self.account_1.account.name,
                                domainid=self.account_1.account.domainid,
                                listall=True
                                )
        self.assertEqual(
                         isinstance(networks, list),
                         True,
                         "List networks should return a valid response"
                         )
        network_1 = networks[0]
        self.debug("Default network in account 1: %s is %s" % (
                                                self.account_1.account.name,
                                                network_1.name))
        src_nat_list = PublicIPAddress.list(
                                        self.apiclient,
                                        associatednetworkid=self.network_1.id,
                                        account=self.account.account.name,
                                        domainid=self.account.account.domainid,
                                        listall=True,
                                        issourcenat=True,
                                        )
        self.assertEqual(
                         isinstance(src_nat_list, list),
                         True,
                         "List Public IP should return a valid source NAT"
                         )
        self.assertNotEqual(
                    len(src_nat_list),
                    0,
                    "Length of response from listPublicIp should not be 0"
                    )

        src_nat = src_nat_list[0]

        self.debug(
            "Trying to create a port forwarding rule in source NAT: %s" %
                                                            src_nat.ipaddress)
        #Create NAT rule
        nat_rule = NATRule.create(
                                  self.apiclient,
                                  vm_1,
                                  self.services["natrule"],
                                  ipaddressid=src_nat.id
                           )
        self.debug("Created PF rule on source NAT: %s" % src_nat.ipaddress)

        nat_rules = NATRule.list(self.apiclient, id=nat_rule.id)

        self.assertEqual(
                         isinstance(nat_rules, list),
                         True,
                         "List NAT should return a valid port forwarding rules"
                         )

        self.assertNotEqual(
                    len(nat_rules),
                    0,
                    "Length of response from listLbRules should not be 0"
                    )

        self.debug("Deleting domain with force option")
        try:
            domain.delete(self.apiclient, cleanup=True)
        except Exception as e:
            self.fail("Failed to delete domain: %s" % e)

        self.debug("Waiting for account.cleanup.interval" +
                   " to cleanup any remaining resouces")

        configurations = Configuration.list(
                                            self.apiclient,
                                            name="account.cleanup.inetrval",
                                            listall=True
                                            )
        self.debug("Account.cleanup.inetrval: %s" %
                                            int(configurations[0].value))
        # Sleep to ensure that all resources are deleted
        time.sleep(int(configurations[0].value) * 2)
        self.debug("Cheking if the resourses in domain are deleted or not..")
        accounts = Account.list(
                                self.apiclient,
                                name=self.account_1.account.name,
                                domainid=self.account_1.account.domainid,
                                listall=True
                                )

        self.assertEqual(
            accounts,
            None,
            "Account should get automatically deleted after domain removal"
            )
        return

    @attr(tags=["domains", "advanced", "advancedns", "simulator"])
    def test_DeleteDomain(self):
        """ Test delete domain with force option"""

        # Steps for validations
        # 1. create a domain DOM
        # 2. create 2 users under this domain
        # 3. deploy 1 VM into each of these user accounts
        # 4. create PF / FW rules for port 22 on these VMs for their
        #    respective accounts
        # 5. delete the domain with force=false option
        # Validate the following
        # 1. listDomains should list the created domain
        # 2. listAccounts should list the created accounts
        # 3. listvirtualmachines should show the Running VMs
        # 4. PF and FW rules should be shown in listFirewallRules
        # 5. domain deletion should fail saying there are resources under use

        self.debug("Creating a domain for login with API domain test")
        domain = Domain.create(
                                self.apiclient,
                                self.services["domain"],
                                parentdomainid=self.domain.id
                                )
        self.debug("Domain: %s is created succesfully." % domain.name)
        self.debug(
            "Checking if the created domain is listed in list domains API")
        domains = Domain.list(self.apiclient, id=domain.id, listall=True)

        self.assertEqual(
                         isinstance(domains, list),
                         True,
                         "List domains shall return a valid response"
                         )
        self.debug("Creating 2 user accounts in domain: %s" % domain.name)
        self.account_1 = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     domainid=domain.id
                                     )
        self.cleanup.append(self.account_1)

        self.account_2 = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     domainid=domain.id
                                     )
        self.cleanup.append(self.account_2)

        self.debug("Creating a tiny service offering for VM deployment")
        self.service_offering = ServiceOffering.create(
                                    self.apiclient,
                                    self.services["service_offering"],
                                    domainid=cls.domain.id
                                    )
        self.cleanup.append(self.service_offering)

        self.debug("Deploying virtual machine in account 1: %s" %
                                                self.account_1.account.name)
        vm_1 = VirtualMachine.create(
                                    self.apiclient,
                                    self.services["virtual_machine"],
                                    templateid=self.template.id,
                                    accountid=self.account_1.account.name,
                                    domainid=self.account_1.account.domainid,
                                    serviceofferingid=self.service_offering.id
                                    )

        self.debug("Deploying virtual machine in account 2: %s" %
                                                self.account_2.account.name)
        vm_2 = VirtualMachine.create(
                                    self.apiclient,
                                    self.services["virtual_machine"],
                                    templateid=self.template.id,
                                    accountid=self.account_2.account.name,
                                    domainid=self.account_2.account.domainid,
                                    serviceofferingid=self.service_offering.id
                                    )

        networks = Network.list(
                                self.apiclient,
                                account=self.account_1.account.name,
                                domainid=self.account_1.account.domainid,
                                listall=True
                                )
        self.assertEqual(
                         isinstance(networks, list),
                         True,
                         "List networks should return a valid response"
                         )
        network_1 = networks[0]
        self.debug("Default network in account 1: %s is %s" % (
                                                self.account_1.account.name,
                                                network_1.name))
        src_nat_list = PublicIPAddress.list(
                                        self.apiclient,
                                        associatednetworkid=self.network_1.id,
                                        account=self.account.account.name,
                                        domainid=self.account.account.domainid,
                                        listall=True,
                                        issourcenat=True,
                                        )
        self.assertEqual(
                         isinstance(src_nat_list, list),
                         True,
                         "List Public IP should return a valid source NAT"
                         )
        self.assertNotEqual(
                    len(src_nat_list),
                    0,
                    "Length of response from listPublicIp should not be 0"
                    )

        src_nat = src_nat_list[0]

        self.debug(
            "Trying to create a port forwarding rule in source NAT: %s" %
                                                            src_nat.ipaddress)
        #Create NAT rule
        nat_rule = NATRule.create(
                                  self.apiclient,
                                  vm_1,
                                  self.services["natrule"],
                                  ipaddressid=src_nat.id
                           )
        self.debug("Created PF rule on source NAT: %s" % src_nat.ipaddress)

        nat_rules = NATRule.list(self.apiclient, id=nat_rule.id)

        self.assertEqual(
                         isinstance(nat_rules, list),
                         True,
                         "List NAT should return a valid port forwarding rules"
                         )

        self.assertNotEqual(
                    len(nat_rules),
                    0,
                    "Length of response from listLbRules should not be 0"
                    )

        self.debug("Deleting domain with force option")
        with self.assertRaises(Exception):
            domain.delete(self.apiclient, cleanup=False)
        return


class TestSharedNetworkWithoutIp(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestSharedNetworkWithoutIp,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services
        # Get Zone, Domain and templates
        cls.domain = get_domain(cls.api_client, cls.services)
        cls.zone = get_zone(cls.api_client, cls.services)
        cls.template = get_template(
                            cls.api_client,
                            cls.zone.id,
                            cls.services["ostypeid"]
                            )
        cls.services["virtual_machine"]["zoneid"] = cls.zone.id
        cls.services["virtual_machine"]["template"] = cls.template.id

        cls.service_offering = ServiceOffering.create(
                                            cls.api_client,
                                            cls.services["service_offering"]
                                            )

        cls._cleanup = [
                        cls.service_offering,
                        ]
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Cleanup resources used
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.account = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     admin=True,
                                     domainid=self.domain.id
                                     )
        self.cleanup = []
        return

    def tearDown(self):
        try:
            self.account.delete(self.apiclient)
            interval = list_configurations(
                                    self.apiclient,
                                    name='account.cleanup.interval'
                                    )
            # Sleep to ensure that all resources are deleted
            time.sleep(int(interval[0].value) * 2)
            #Clean up, terminate the created network offerings
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=["advanced", "advancedns", "simulator", "network", "api"])
    def test_deployVmSharedNetworkWithoutIpRange(self):
        """Test deployVM in shared network without startIp/endIp
        """

        # Steps for validation
        # 1. create a shared network using shared network offering but do not
        #    specify startIp/endIp arguments
        # 2. create an account
        # 3. deploy a VM in this account using the above network
        # Validate the following
        # 1. listNetworks should return the created network
        # 2. listAccounts to return the created account
        # 3. VM deployment should succeed and NIC is in networks address space
        # 4. delete the account

        self.debug(
                "Fetching default shared network offering from nw offerings")
        network_offerings = NetworkOffering.list(
                                    self.apiclient,
                                    listall=True,
                                    guestiptype="Shared",
                                    name="DefaultSharedNetworkOffering",
                                    displaytext="Offering for Shared networks"
                                    )
        self.assertEqual(
                    isinstance(network_offerings, list),
                    True,
                    "Nw offerings should have atleast a shared nw offering"
                    )
        shared_nw_off = network_offerings[0]
        self.debug("Shared netwrk offering: %s" % shared_nw_off.name)

        self.debug("Creating a network from shared network offering")
        self.network = Network.create(
                                    self.apiclient,
                                    self.services["network"],
                                    accountid=self.account.account.name,
                                    domainid=self.account.account.domainid,
                                    networkofferingid=shared_nw_off.id,
                                    zoneid=self.zone.id
                                    )
        self.debug("Created network with ID: %s" % self.network.id)

        self.debug("Deploying VM in account: %s" % self.account.account.name)
        try:
            # Spawn an instance in that network
            VirtualMachine.create(
                                  self.apiclient,
                                  self.services["virtual_machine"],
                                  accountid=self.account.account.name,
                                  domainid=self.account.account.domainid,
                                  serviceofferingid=self.service_offering.id,
                                  networkids=[str(self.network.id)]
                                  )
            self.debug("Deployed VM in network: %s" % self.network.id)
        except Exception as e:
            self.fail("Deply Vm in shared network failed! - %s" % e)
        return


class TestDeployVmWithCustomDisk(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestDeployVmWithCustomDisk,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services

        # Get Zone, Domain and templates
        cls.domain = get_domain(cls.api_client, cls.services)
        cls.zone = get_zone(cls.api_client, cls.services)
        cls.disk_offering = DiskOffering.create(
                                    cls.api_client,
                                    cls.services["disk_offering"],
                                    custom=True
                                    )
        template = get_template(
                            cls.api_client,
                            cls.zone.id,
                            cls.services["ostypeid"]
                            )
        cls.services["zoneid"] = cls.zone.id
        cls.services["virtual_machine"]["zoneid"] = cls.zone.id
        cls.services["virtual_machine"]["template"] = template.id

        # Create VMs, NAT Rules etc
        cls.account = Account.create(
                            cls.api_client,
                            cls.services["account"],
                            domainid=cls.domain.id
                            )

        cls.services["account"] = cls.account.account.name
        cls.service_offering = ServiceOffering.create(
                                            cls.api_client,
                                            cls.services["service_offering"]
                                            )
        cls._cleanup = [
                        cls.service_offering,
                        cls.disk_offering,
                        cls.account
                        ]

    def setUp(self):

        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.cleanup = []

    @attr(tags=["advanced", "configuration", "advancedns", "simulator",
                "api", "basic", "eip", "sg"])
    def test_deployVmWithCustomDisk(self):
        """Test custom disk sizes beyond range
        """
        # Steps for validation
        # 1. listConfigurations - custom.diskoffering.size.min
        #    and custom.diskoffering.size.max
        # 2. deployVm with custom disk offering size < min
        # 3. deployVm with custom disk offering min< size < max
        # 4. deployVm with custom disk offering size > max
        # Validate the following
        # 2. and 4. of deploy VM should fail.
        #    Only case 3. should succeed.
        #    cleanup all created data disks from the account

        config = Configuration.list(
                                    self.apiclient,
                                    name="custom.diskoffering.size.min"
                                    )
        self.assertEqual(
            isinstance(config, list),
            True,
            "custom.diskoffering.size.min should be present in global config"
            )
        # minimum size of custom disk (in GBs)
        min_size = int(config[0].value)
        self.debug("custom.diskoffering.size.min: %s" % min_size)

        config = Configuration.list(
                                    self.apiclient,
                                    name="custom.diskoffering.size.max"
                                    )
        self.assertEqual(
            isinstance(config, list),
            True,
            "custom.diskoffering.size.min should be present in global config"
            )
        # maximum size of custom disk (in GBs)
        max_size = int(config[0].value)
        self.debug("custom.diskoffering.size.max: %s" % max_size)

        self.debug("Creating a volume with size less than min cust disk size")
        self.services["custom_volume"]["customdisksize"] = (min_size - 1)
        with self.assertRaises(Exception):
            Volume.create_custom_disk(
                                    self.apiClient,
                                    self.services["custom_volume"],
                                    account=self.account.account.name,
                                    domainid=self.account.account.domainid,
                                    diskofferingid=self.disk_offering.id
                                    )
        self.debug("Create volume failed!")

        self.debug("Creating a volume with size more than max cust disk size")
        self.services["custom_volume"]["customdisksize"] = (max_size + 1)
        with self.assertRaises(Exception):
            Volume.create_custom_disk(
                                    self.apiClient,
                                    self.services["custom_volume"],
                                    account=self.account.account.name,
                                    domainid=self.account.account.domainid,
                                    diskofferingid=self.disk_offering.id
                                    )
        self.debug("Create volume failed!")

        self.debug("Creating a volume with size more than min cust disk " +
                   "but less than max cust disk size"
                   )
        self.services["custom_volume"]["customdisksize"] = (min_size + 1)
        try:
            Volume.create_custom_disk(
                                    self.apiClient,
                                    self.services["custom_volume"],
                                    account=self.account.account.name,
                                    domainid=self.account.account.domainid,
                                    diskofferingid=self.disk_offering.id
                                    )
            self.debug("Create volume of cust disk size succeeded")
        except Exception as e:
            self.fail("Create volume failed with exception: %s" % e)
        return


class TestSingleSignOnEncryption(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestSingleSignOnEncryption,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services
        # Get Zone, Domain and templates
        cls.domain = get_domain(cls.api_client, cls.services)
        cls.zone = get_zone(cls.api_client, cls.services)
        cls._cleanup = []
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Cleanup resources used
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.cleanup = []
        return

    def tearDown(self):
        try:
            #Clean up, terminate the created network offerings
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=["advanced", "configuration", "advancedns", "simulator",
                "api", "basic", "eip", "sg"])
    def test_SingleSignOnEncryption(self):
        """List listConfigurations API should get decrypted
            security.singlesignon.key
        """

        # Steps for validation
        # 1. listConfigurations - security.singlesignon.key
        # Validate the following
        # 1. assert that the field is encrypted (value mismatch)
        # 2. assert that section of the DB for this config is "Secure"
        #    and not "Hidden"

        config = Configuration.list(
                                    self.apiclient,
                                    name='security.singlesignon.key',
                                    listall=True
                                    )
        self.assertEqual(
                isinstance(config, list),
                True,
                "List configurations hsould have security.singlesignon.key"
                )

        config_value = config[0].value
        config_category = config[0].category
        qresultset = self.dbclient.execute(
                        "select value from configuration where name='security.singlesignon.key';"
                        )
        self.assertEqual(
                         isinstance(qresultset, list),
                         True,
                         "Check DB query result set for valid data"
                         )
        self.assertNotEqual(
                         qresultset[0][0],
                         config_value,
                         "The security.singlesignon.key is not encrypted"
                         )
        self.assertEqual(
                         config_category,
                         "Secure",
                         "The configuration category should be secure"
                         )
        return


class TestDeployOnSpecificHost(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestDeployOnSpecificHost,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services
        # Get Zone, Domain and templates
        cls.domain = get_domain(cls.api_client, cls.services)
        cls.zone = get_zone(cls.api_client, cls.services)
        cls.template = get_template(
                            cls.api_client,
                            cls.zone.id,
                            cls.services["ostypeid"]
                            )
        cls.services["virtual_machine"]["zoneid"] = cls.zone.id
        cls.services["virtual_machine"]["template"] = cls.template.id

        cls.service_offering = ServiceOffering.create(
                                            cls.api_client,
                                            cls.services["service_offering"]
                                            )

        cls._cleanup = [
                        cls.service_offering,
                        ]
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Cleanup resources used
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.account = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     admin=True,
                                     domainid=self.domain.id
                                     )
        self.cleanup = []
        return

    def tearDown(self):
        try:
            self.account.delete(self.apiclient)
            interval = list_configurations(
                                    self.apiclient,
                                    name='account.cleanup.interval'
                                    )
            # Sleep to ensure that all resources are deleted
            time.sleep(int(interval[0].value) * 2)
            #Clean up, terminate the created network offerings
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=["advanced", "advancedns", "simulator",
                "api", "basic", "eip", "sg"])
    def test_deployVmOnGivenHost(self):
        """Test deploy VM on specific host
        """

        # Steps for validation
        # 1. as admin list available hosts that are Up
        # 2. deployVM with hostid=above host
        # 3. listVirtualMachines
        # 4. destroy VM
        # Validate the following
        # 1. listHosts returns at least one host in Up state
        # 2. VM should be in Running
        # 3. VM should be on the host that it was deployed on

        hosts = Host.list(
                          self.apiclient,
                          zoneid=self.zone.id,
                          type='Routing',
                          state='Up',
                          listall=True
                          )

        self.assertEqual(
                         isinstance(hosts, list),
                         True,
                         "CS should have atleast one host Up and Running"
                         )

        host = hosts[0]
        self.debug("Deploting VM on host: %s" % host.name)

        try:
            vm = VirtualMachine.create(
                                    self.apiclient,
                                    self.services["virtual_machine"],
                                    templateid=self.template.id,
                                    accountid=self.account.account.name,
                                    domainid=self.account.account.domainid,
                                    serviceofferingid=self.service_offering.id,
                                    hostid=host.id
                                    )
            self.debug("Deploy VM succeeded")
        except Exception as e:
            self.fail("Deploy VM failed with exception: %s" % e)

        self.debug("Cheking the state of deployed VM")
        vms = VirtualMachine.list(
                                self.apiclient,
                                id=vm.id,
                                listall=True,
                                account=self.account.account.name,
                                domainid=self.account.account.domainid
                                )

        self.assertEqual(
                         isinstance(vms, list),
                         True,
                         "List Vm should return a valid response"
                         )

        vm_response = vms[0]
        self.assertEqual(
                         vm_response.state,
                         "Running",
                         "VM should be in running state after deployment"
                         )
        self.assertEqual(
                         vm_response.hostid,
                         host.id,
                         "Host id where VM is deployed should match"
                         )
        return


class TestMaxAccountNetworks(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestMaxAccountNetworks,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services
        # Get Zone, Domain and templates
        cls.domain = get_domain(cls.api_client, cls.services)
        cls.zone = get_zone(cls.api_client, cls.services)
        cls.template = get_template(
                            cls.api_client,
                            cls.zone.id,
                            cls.services["ostypeid"]
                            )

        cls.service_offering = ServiceOffering.create(
                                            cls.api_client,
                                            cls.services["service_offering"]
                                            )
        cls.network_offering = NetworkOffering.create(
                                            cls.api_client,
                                            cls.services["network_offering"],
                                            conservemode=True
                                            )
        # Enable Network offering
        cls.network_offering.update(cls.api_client, state='Enabled')

        cls._cleanup = [
                        cls.service_offering,
                        cls.network_offering
                        ]
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Cleanup resources used
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.account = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     admin=True,
                                     domainid=self.domain.id
                                     )
        self.cleanup = []
        return

    def tearDown(self):
        try:
            self.account.delete(self.apiclient)
            interval = list_configurations(
                                    self.apiclient,
                                    name='account.cleanup.interval'
                                    )
            # Sleep to ensure that all resources are deleted
            time.sleep(int(interval[0].value) * 2)
            #Clean up, terminate the created network offerings
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=["advanced", "advancedns", "simulator",
                "api", "basic", "eip", "sg"])
    def test_maxAccountNetworks(self):
        """Test Limit number of guest account specific networks
        """

        # Steps for validation
        # 1. Fetch max.account.networks from configurations
        # 2. Create an account. Create account more that max.accout.network
        # 3. Create network should fail

        config = Configuration.list(
                                    self.apiclient,
                                    name='max.account.networks',
                                    listall=True
                                    )
        self.assertEqual(
                isinstance(config, list),
                True,
                "List configurations hsould have max.account.networks"
                )

        config_value = int(config[0].value)
        self.debug("max.account.networks: %s" % config_value)

        for ctr in range(config_value):
            # Creating network using the network offering created
            self.debug("Creating network with network offering: %s" %
                                                    self.network_offering.id)
            Network.create(
                                    self.apiclient,
                                    self.services["network"],
                                    accountid=self.account.account.name,
                                    domainid=self.account.account.domainid,
                                    networkofferingid=self.network_offering.id,
                                    zoneid=self.zone.id
                                    )
            self.debug("Created network with ID: %s" % self.network.id)
        self.debug(
            "Creating network in account already having networks : %s" %
                                                            config_value)

        with self.assertRaises(Exception):
            Network.create(
                                    self.apiclient,
                                    self.services["network"],
                                    accountid=self.account.account.name,
                                    domainid=self.account.account.domainid,
                                    networkofferingid=self.network_offering.id,
                                    zoneid=self.zone.id
                                    )
        self.debug('Create network failed (as expected)')
        return


class TestMaxProjectNetworks(cloudstackTestCase):

    @classmethod
    def setUpClass(cls):
        cls.api_client = super(
                               TestMaxProjectNetworks,
                               cls
                               ).getClsTestClient().getApiClient()
        cls.services = Services().services
        # Get Zone, Domain and templates
        cls.domain = get_domain(cls.api_client, cls.services)
        cls.zone = get_zone(cls.api_client, cls.services)
        cls.template = get_template(
                            cls.api_client,
                            cls.zone.id,
                            cls.services["ostypeid"]
                            )
        cls.service_offering = ServiceOffering.create(
                                            cls.api_client,
                                            cls.services["service_offering"]
                                            )
        cls.network_offering = NetworkOffering.create(
                                            cls.api_client,
                                            cls.services["network_offering"],
                                            conservemode=True
                                            )
        # Enable Network offering
        cls.network_offering.update(cls.api_client, state='Enabled')

        cls._cleanup = [
                        cls.service_offering,
                        cls.network_offering
                        ]
        return

    @classmethod
    def tearDownClass(cls):
        try:
            #Cleanup resources used
            cleanup_resources(cls.api_client, cls._cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    def setUp(self):
        self.apiclient = self.testClient.getApiClient()
        self.dbclient = self.testClient.getDbConnection()
        self.account = Account.create(
                                     self.apiclient,
                                     self.services["account"],
                                     admin=True,
                                     domainid=self.domain.id
                                     )
        self.cleanup = []
        return

    def tearDown(self):
        try:
            self.account.delete(self.apiclient)
            interval = list_configurations(
                                    self.apiclient,
                                    name='account.cleanup.interval'
                                    )
            # Sleep to ensure that all resources are deleted
            time.sleep(int(interval[0].value) * 2)
            #Clean up, terminate the created network offerings
            cleanup_resources(self.apiclient, self.cleanup)
        except Exception as e:
            raise Exception("Warning: Exception during cleanup : %s" % e)
        return

    @attr(tags=["advanced", "advancedns", "simulator",
                "api", "basic", "eip", "sg"])
    def test_maxAccountNetworks(self):
        """Test Limit number of guest account specific networks
        """

        # Steps for validation
        # 1. Fetch max.account.networks from configurations
        # 2. Create an account. Create account more that max.accout.network
        # 3. Create network should fail

        self.debug("Creating project with '%s' as admin" %
                                            self.account.account.name)
        # Create project as a domain admin
        project = Project.create(
                                 self.apiclient,
                                 self.services["project"],
                                 account=self.admin.account.name,
                                 domainid=self.admin.account.domainid
                                 )
        # Cleanup created project at end of test
        self.cleanup.append(project)
        self.debug("Created project with domain admin with ID: %s" %
                                                                project.id)

        config = Configuration.list(
                                    self.apiclient,
                                    name='max.project.networks',
                                    listall=True
                                    )
        self.assertEqual(
                isinstance(config, list),
                True,
                "List configurations hsould have max.project.networks"
                )

        config_value = int(config[0].value)
        self.debug("max.project.networks: %s" % config_value)

        for ctr in range(config_value):
            # Creating network using the network offering created
            self.debug("Creating network with network offering: %s" %
                                                    self.network_offering.id)
            Network.create(
                                    self.apiclient,
                                    self.services["network"],
                                    projectid=project.id,
                                    networkofferingid=self.network_offering.id,
                                    zoneid=self.zone.id
                                    )
            self.debug("Created network with ID: %s" % self.network.id)
        self.debug(
            "Creating network in account already having networks : %s" %
                                                            config_value)

        with self.assertRaises(Exception):
            Network.create(
                                    self.apiclient,
                                    self.services["network"],
                                    projectid=project.id,
                                    networkofferingid=self.network_offering.id,
                                    zoneid=self.zone.id
                                    )
        self.debug('Create network failed (as expected)')
        return